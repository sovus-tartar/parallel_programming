### Анализ цикла

a[i][j] = f(a[i-3][j+2])

a[3][0] = f(a[0][2])
a[3][1] = f(a[0][3])
a[3][2] = f(a[0][4])
a[3][3] = f(a[0][5])
a[3][4] = f(a[0][6])
a[3][5] = f(a[0][7])
a[3][6] = f(a[0][8])
...
a[4][0] = f(a[1][2])
a[4][1] = f(a[1][3])
a[4][2] = f(a[1][4])
a[4][3] = f(a[1][5])
a[4][4] = f(a[1][6])
a[4][5] = f(a[1][7])
a[4][6] = f(a[1][8])
...
a[5][0] = f(a[2][2])
a[5][1] = f(a[2][3])
a[5][2] = f(a[2][4])
a[5][3] = f(a[2][5])
a[5][4] = f(a[2][6])
a[5][5] = f(a[2][7])
a[5][6] = f(a[2][8])
...
a[6][0] = f(a[3][2])
a[6][1] = f(a[3][3])
a[6][2] = f(a[3][4])
a[6][3] = f(a[3][5])
a[6][4] = f(a[3][6])
a[6][5] = f(a[3][7])
a[6][6] = f(a[3][8])

Так как требуется реализация на MPI (то есть с разделённой памятью), то для минимизации количества посылок имеет смысл считать все блоки с одинаковыми i по очереди и по отдельности, а внутри блока расчёты производить параллельно

Результаты измерений, 10000х10000:
1 поток     - 1.09s
2 потока    - 0.63s
3 потока    - 0.51s
4 потока    - 0.51s
# Решение краевой задачи (Простой уровень)

Для читаемости математических формул лучше пользоваться рендерером markdown в vscode

## Аппроксимация Нумерова

$\frac{y_{m+1} - 2y_m + y_{m-1}}{h^2} = f_m + \frac{1}{12} (f_{m+1} - 2f_m + f_{m-1})$

Выражаем $y_{m+1}$: 

$y_{m+1} = 2y_m - y_{m-1} + h^2 * f(x_m; y_m)$

Матрица СЛУ для метода Нумерова:

$
A =
    {
    \begin{pmatrix}
    2 & -1 & 0 & 0 & \dots& 0 \\
    -1 & 2 & -1 & 0 & \dots & 0 \\
    0 & -1 & 2 & 1  & \dots & 0 \\
    \vdots & \vdots & \vdots & \vdots & \ddots & 0 \\
    0 & 0 & \dots & -1 & 2 & -1
    \end{pmatrix}
    }
$

Для каждой итерации прогонки необходимо решать СЛУ:

$
{
\begin{pmatrix}
2 & -1 & 0 & 0 & \dots& 0 \\
-1 & 2 & -1 & 0 & \dots & 0 \\
0 & -1 & 2 & 1  & \dots & 0 \\
\vdots & \vdots & \vdots & \vdots & \ddots & 0 \\
0 & 0 & \dots & -1 & 2 & -1
\end{pmatrix}
}
\begin{pmatrix}
y_1^{(k)} \\
y_2^{(k)} \\
y_3^{(k)} \\
\vdots \\
y_{N-1}^{(k)}
\end {pmatrix}
{=} 
\begin{pmatrix}
h^2f(x_1;y_1^{(k-1)}) \\
h^2f(x_2;y_2^{(k-1)}) \\
h^2f(x_3;y_3^{(k-1)}) \\
\vdots \\
h^2f(x_{N-1};y_{N-1}^{(k-1)})
\end {pmatrix}
$

Для решения этой СЛУ используется метод Гаусса

## Метод Гаусса

### Прямой ход

Суть прямого хода метода Гаусса заключается в устранении элементов ниже диагонали, например:

$
\begin{pmatrix}
2 & -1 & 0 & 0 \\
0 & 2 & -1 & 0  \\
0 & -1 & 2 & -1 \\
0 & 0 & -1 & 2 \\
\end{pmatrix}
{\sim}
\begin{pmatrix}
1 & -\frac{1}{2} & 0 & 0 \\
0 & \frac{3}{2} & -1 & 0  \\
0 & -1 & 2 & -1 \\
0 & 0 & -1 & 2 \\
\end{pmatrix}
{\sim}
\begin{pmatrix}
1 & -\frac{1}{2} & 0 & 0 \\
0 & 1 & \frac{2}{3} & 0  \\
0 & 0 & \frac{4}{3} & -1 \\
0 & 0 & -1 & 2 \\
\end{pmatrix}
{\sim}
\begin{pmatrix}
1 & -\frac{1}{2} & 0 & 0 \\
0 & 1 & \frac{2}{3} & 0  \\
0 & 0 & 1 & -\frac{3}{4} \\
0 & 0 & 0 & 1 \\
\end{pmatrix}
$

При прямом ходе метода Гаусса происходит распараллеливание в рамках внутренних строк. То есть пусть мы фиксируем `k` - номер строки. Тогда операции вычитания `k`-ой стройки (с домножением) из из остальных могут быть исполнены в любом порядке. Здесь и происходит распараллеливание.

### Обратный ход

Суть обратного хода метода Гаусса заключается в устранении верхнедиагональных элементов:

$
\begin{pmatrix}
1 & -\frac{1}{2} & 0 & 0 \\
0 & 1 & \frac{2}{3} & 0  \\
0 & 0 & 1 & -\frac{3}{4} \\
0 & 0 & 0 & 1 \\
\end{pmatrix}
{\sim}
\begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0  \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1 \\
\end{pmatrix}
$

При обратном ходе метода Гаусса для каждой строки, в программе не происходит изменений в левой части матрицы - лишь подсчёт корней (`X[i] : 41`). В рамках одной строки это параллелится

## Проблема!

В силу мелкости изменения корни получаются довольно малые. Из-за этого набегают большие ошибки. Поэтому принято решение использовать матрицу Якоби для решения, а также базовые свойства производной

## Решение

### Матрица Якоби

Коэффициенты определяются так:

$
{J_{i, i} = -2 - \frac{10}{12}h^2*f(x_{i+1}, y_{i+1})}
$

$
{J_{i, i+1} = 1 - \frac{1}{12}h^2*f(x_{i+2}, y_{i+2})}
$

$
{J_{i, i-1} = 1 - \frac{1}{12}h^2*f(x_{i}, y_{i})}
$

### Уравнение

Решается СЛУ:

$
{J * \Delta Y = B}
$

На каждой итерации метода Ньютона:

$
{Y_i = Y_i + {\Delta Y}_i}
$

### Первое приближение

В качестве первого приближения используется прямая:

${y = x}$

## Компиляция

MacOS:

    clang -Xclang -fopenmp -L/opt/homebrew/opt/libomp/lib -I/opt/homebrew/opt/libomp/include -lomp main.c -o main

Linux:

    gcc -fopenmp main.c -o main -lm

## Использование

Расчёт:

    ./main.out {число потоков} {число итерация Метода Ньютона}

Построение графика решения:

    python3 plot.py

Для построения графика необходимы `numpy` и `matplotlib`

## Эффективность
Замерялось при количестве итераций метода Ньютона `5`

| Число потоков | Время | Ускорение |
|---            |---    |---        |
| 1             | 5.55s |     1     |
| 2             | 2.82s |    1.96   |
| 4             | 2.10s |    2.64   |
| 8             | 2.07s |    2.68   |
